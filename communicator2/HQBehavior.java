package communicator2;

import java.util.ArrayList;

import battlecode.common.*;

public class HQBehavior {
	
	/**
	 * 
	 * Defines the possible states the HQ can take in.
	 * 
	 */
	private enum HQState{
		INIT,DEFAULT;
	}
	
	/**
	 * 
	 * Represents what the HQ knows about a soldier.
	 * This representation needs maintains through constant updates.
	 * 
	 */
	private static class RobotRepresentation{
		int currentCommand;
		int iD;
		int lifeTime;
		boolean initilazie;
		MapLocation mL;
		public RobotRepresentation(int iD){
			this.initilazie = true;
			this.iD = iD;
			this.lifeTime = 0;
			this.currentCommand = StaticVariables.COMMAND_NOT_RECEIVED_YET;
		}
	}
	
	/** locations that are generated by MapMaker are showing building positions**/
	public static MapLocation[] assemblyPositions;
	
	/** storage for the last target for the soldiers**/
	public static MapLocation lastTarget;
	
	public static MapLocation enemyHQ;
	public static MapLocation thisPos;
	
	/** The current state of the HQ. Allows to separate logical areas**/
	public static HQState state = HQState.INIT;
	
	/** contains the models the HQ has of the soldiers**/
	public static RobotRepresentation[] robots = new RobotRepresentation[StaticVariables.MAX_ROBOTS_SPAWN];
	
	
	public static ArrayList<RobotRepresentation> attacking = new ArrayList<RobotRepresentation>();
	public static ArrayList<RobotRepresentation> assembling= new ArrayList<RobotRepresentation>();
	public static ArrayList<RobotRepresentation> building= new ArrayList<RobotRepresentation>();
	public static ArrayList<RobotRepresentation> free= new ArrayList<RobotRepresentation>();
	
	
	/** debugging constant **/
	static int lifeCount = 0;
	/** debugging constant **/
	static int byteCodeSum = 0;
	
	
	/**
	 * Contains the logic of the HQ. is called every round.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void hqBehavior(RobotController rc) throws Exception{
		int prevByteCode = Clock.getBytecodeNum();
		lifeCount ++;
		switch (state) {
		case INIT:
			enemyHQ = rc.senseEnemyHQLocation();
			thisPos = rc.getLocation();
			MapMaker.searchForSpots(rc, 0);
			// builds internal map which is currently unused
//			MapMaker.makeMap(rc);
//			assemblyPositions = MapMaker.buildImportanceMap(2,rc);
			assemblyPositions = new MapLocation[1];
			assemblyPositions[0] = MapMaker.bestFound;
			state = HQState.DEFAULT;
			break;
		case DEFAULT:
//			System.out.println(lifeCount + " try to spawn: " + rc.senseRobotCount());
			tryToSpawn(rc);
			deliverID(rc);
			updateInteralRobotRepresentation(rc);
			MapLocation[] enemyPastr = rc.sensePastrLocations(rc.getTeam().opponent());
			
			if(enemyPastr.length > 0){
				if(lastTarget == null){
					assignSoldiersToGroup(free,attacking,0,100);
					assignSoldiersToGroup(assembling,attacking,0,100);
					HQBehavior.deliverCommandToGroup(attacking, rc, StaticVariables.COMMAND_ATTACK_LOCATION, enemyPastr[0]);
					lastTarget = enemyPastr[0];
				}else if(enemyPastr[0].x != lastTarget.x && enemyPastr[0].y != lastTarget.y){
					lastTarget = null;
				}else if(free.size() > 0 || assembling.size()>0 ){
					assignSoldiersToGroup(free,attacking,0,100);
					assignSoldiersToGroup(assembling,attacking,0,100);
					HQBehavior.deliverCommandToGroup(attacking, rc, StaticVariables.COMMAND_ATTACK_LOCATION, enemyPastr[0]);
					lastTarget = enemyPastr[0];
				}
			}else{
				int size = assembling.size();
				assignSoldiersToGroup(free,assembling,0,100);
				assignSoldiersToGroup(attacking,assembling,0,100);
				if(size != assembling.size()){
					HQBehavior.deliverCommandToGroup(assembling, rc, StaticVariables.COMMAND_ASSEMBLE_AT_LOCATION, assemblyPositions[0]);
				}
			}
			// after a while send a build-pasture-command to the last spawned soldier.
			if(lifeCount >= 400 &&rc.sensePastrLocations(rc.getTeam()).length == 0){
				assignSoldiersToGroup(assembling,building,0,1);
				deliverCommandToGroup(building,rc,StaticVariables.COMMAND_BUILD_PASTR,assemblyPositions[0]);
			}
			//send scout soldier
			if(enemyPastr.length == 0){
				for(int i = 0; i < robots.length; i ++){
					if(robots[i] != null){
						sendCommand(enemyHQ, StaticVariables.ROBOT_COMMAND_CHANNEL_START+i, rc, StaticVariables.COMMAND_SCOUT_LOCATION);
						break;
					}
				}
			}
			break;
		}
		byteCodeSum +=  Clock.getBytecodeNum()-prevByteCode;
//		System.out.println(byteCodeSum/Clock.getRoundNum());
	}
	
	/**
	 * Reeds the feedback from all soldiers and updates the internal representation of the robots.
	 * This contains a counter that indicates if the soldier is alive, and also the map location
	 * of the soldiers.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void updateInteralRobotRepresentation(RobotController rc) throws Exception{

		for(int i=StaticVariables.MAX_ROBOTS_SPAWN; --i >= 0;) {
			if(robots[i] != null){
				
				//reeds the feedback associated with this soldier.
				int feedBack = rc.readBroadcast(StaticVariables.ROBOT_FEEDBACK_CHANNEL_START+i);
				
				//remembers the old life count of the soldier
				int current = robots[i].lifeTime;
				
				//sets the lifecount of the soldier to the new value. 
				robots[i].lifeTime = feedBack;
				
				//Interpreters the feedback to get the maplocation of the soldier.
				robots[i].mL = new MapLocation(feedBack/1000,(feedBack/10)%100);
				
				//if the old lifecount is equal to the current, than the soldier died because he didn't send new feedback.
				//its a special case if the robot just spawned, in this case the previous feedback is equal to the current.
				//This continues until the soldier sends the first time some feedback.
				if(feedBack == current && !robots[i].initilazie){
					robots[i] = null;
					rc.broadcast(StaticVariables.ROBOT_FEEDBACK_CHANNEL_START+i,0);
				}else if(feedBack != current){
					robots[i].initilazie = false;
				}
			}
		}
	}

	/**
	 * Sends the same command to every soldier in a certain group.
	 * @param group
	 * @param rc
	 * @param command
	 * @param loc
	 * @throws Exception
	 */
	public static void deliverCommandToGroup(ArrayList<RobotRepresentation> group, RobotController rc, int command, MapLocation loc) throws Exception{
		for(int i = 0; i < group.size(); i ++){
			sendCommand(loc, StaticVariables.ROBOT_COMMAND_CHANNEL_START+group.get(i).iD, rc, command);
		}
	}
	/**
	 * Moves N soldiers from one list to the other.
	 * @param from
	 * @param to
	 * @param amount of soldiers to be moved.
	 */
	public static void assignSoldiersToGroup( ArrayList<RobotRepresentation> from, ArrayList<RobotRepresentation> to, int minFrom, int minTo){
		int possible = from.size()-minFrom;
		int wanted = Math.min(possible, minTo-to.size());
		if(from.size() == 0){
			return;
		}
		for(int i = 0; i < wanted; i ++){
			to.add(from.get(i));
		}
		for(int i = 0; i < wanted; i ++){
			from.remove(0);
		}
	}

	
	/**
	 * Reads the broadcast channel allocated for the robot id's.
	 * A 1 stands for a request for a new ID. The HQ looks for the next free space
	 * in the list of soldier-representations. The index of this channel +1 is the new 
	 * ID which is written back into the ID-channel. The Soldier reads this ID and clears
	 * the ID-channel(writing 0 into the ID-channel) for new requests.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void deliverID(RobotController rc) throws Exception{
		int current = rc.readBroadcast(StaticVariables.ROBOT_ID_CHANNEL);
		if(current == 1){
			for(int i = 0; i < robots.length; i ++){
				if(robots[i] == null){
					rc.broadcast(StaticVariables.ROBOT_ID_CHANNEL, (i+1)*10);
					robots[i] = new RobotRepresentation(i);
					free.add(robots[i]);
					return;
				}
			}
		}
	}

	public static void tryToSpawn(RobotController rc) throws Exception{
		if(rc.isActive()){
			int count = rc.senseRobotCount();
			if (count < StaticVariables.MAX_ROBOTS_SPAWN) {
				Direction toEnemy = rc.getLocation().directionTo(
						rc.senseEnemyHQLocation());
				if (rc.senseObjectAtLocation(rc.getLocation().add(toEnemy)) == null) {
					rc.spawn(toEnemy);
				}
			}
		}
	}
	
	/**
	 * Sends a specific command to a certain channel. Incorporates a maplocation into the command.
	 * 
	 * @param loc is the target maplocation delivered to the soldiers. 
	 * @param channelID is the index of the channel in which the command is delivered.
	 * @param rc
	 * @param command
	 * @throws Exception
	 */
	public static void sendCommand(MapLocation loc, int channelID, RobotController rc, int command) throws Exception{
		int broadcast = StaticFunctions.locToInt(loc) + (10000 * command);
		rc.broadcast(channelID, broadcast);
	}
	
}
