package communicator2;

import java.util.ArrayList;

import battlecode.common.*;

public class HQBehavior {

	/**
	 * 
	 * Defines the possible states the HQ can take in.
	 * 
	 */
	private enum HQState{
		INIT,DEFAULT;
	}

	/**
	 * 
	 * Represents what the HQ knows about a soldier.
	 * This representation needs maintains through constant updates.
	 * 
	 */


	/** locations that are generated by MapMaker are showing building positions**/
	public static MapLocation[] assemblyPositions;

	/** storage for the last target for the soldiers**/
	public static MapLocation lastTarget;

	public static MapLocation enemyHQ;
	public static MapLocation thisPos;

	/** The current state of the HQ. Allows to separate logical areas**/
	public static HQState state = HQState.INIT;

	/** contains the models the HQ has of the soldiers**/
	public static RobotRepresentation[] robots = new RobotRepresentation[StaticVariables.MAX_ROBOTS_SPAWN];

	/** containing all possible groups*/
	public static Group[] groups;

	public static OpponentModel om = new OpponentModel();

	/** debugging constant **/
	static int lifeCount = 0;
	/** debugging constant **/
	static int byteCodeSum = 0;


	/**
	 * Contains the logic of the HQ. is called every round.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void hqBehavior(RobotController rc) throws Exception{
		lifeCount ++;
		switch (state) {
		case INIT:
			enemyHQ = rc.senseEnemyHQLocation();
			thisPos = rc.getLocation();
			MapMaker.searchForSpots(rc, 0);
			assemblyPositions = new MapLocation[1];
			assemblyPositions[0] = MapMaker.bestFound;
			state = HQState.DEFAULT;
			groups = new Group[StaticVariables.MAX_POSSIBLE_GROUPS];
			for(int i = 0; i < groups.length; i ++){
				groups[i] = new Group();
			}
			break;
		case DEFAULT:
			tryToSpawn(rc);
			deliverID(rc);
			updateInteralRobotRepresentation(rc);
			groups[0].assignToOtherGroup(rc, groups[1], 0, 19);
			adaptToOpponent(rc,groups);
			groups[1].sendCommandToGroup(rc.senseEnemyHQLocation(), StaticVariables.COMMAND_ATTACK_LOCATION, rc);
			System.out.println("Attacking group " + groups[1].getSize());
			System.out.println("PASTR group 2 " +groups[2].getSize());
			System.out.println("PASTR group 3 " +groups[3].getSize());
			groups[2].sendCommandToGroup(MapMaker.bestFound, StaticVariables.COMMAND_BUILD_PASTR, rc);
			groups[3].sendCommandToGroup(MapMaker.secondBestFound, StaticVariables.COMMAND_BUILD_PASTR, rc);
			break;
		}
	}

	/**
	 * Reeds the feedback from all soldiers and updates the internal representation of the robots.
	 * This contains a counter that indicates if the soldier is alive, and also the map location
	 * of the soldiers.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void updateInteralRobotRepresentation(RobotController rc) throws Exception{

		for(int i=StaticVariables.MAX_ROBOTS_SPAWN; --i >= 0;) {
			if(robots[i] != null){

				//reeds the feedback associated with this soldier.
				int feedBack = rc.readBroadcast(StaticVariables.ROBOT_FEEDBACK_CHANNEL_START+i);

				//remembers the old life count of the soldier
				int current = robots[i].lifeTime;

				//sets the lifecount of the soldier to the new value. 
				robots[i].lifeTime = feedBack;

				//Interpreters the feedback to get the maplocation of the soldier.
				robots[i].mL = new MapLocation(feedBack/1000,(feedBack/10)%100);

				//if the old lifecount is equal to the current, than the soldier died because he didn't send new feedback.
				//its a special case if the robot just spawned, in this case the previous feedback is equal to the current.
				//This continues until the soldier sends the first time some feedback.
				if(feedBack == current && !robots[i].initilazie){
					robots[i] = null;
					rc.broadcast(StaticVariables.ROBOT_FEEDBACK_CHANNEL_START+i,0);
				}else if(feedBack != current){
					robots[i].initilazie = false;
				}
			}
		}
	}

	/**
	 * Reads the broadcast channel allocated for the robot id's.
	 * A 1 stands for a request for a new ID. The HQ looks for the next free space
	 * in the list of soldier-representations. The index of this channel +1 is the new 
	 * ID which is written back into the ID-channel. The Soldier reads this ID and clears
	 * the ID-channel(writing 0 into the ID-channel) for new requests.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void deliverID(RobotController rc) throws Exception{
		int current = rc.readBroadcast(StaticVariables.ROBOT_ID_CHANNEL);
		if(current == 1){
			for(int i = 0; i < robots.length; i ++){
				if(robots[i] == null){
					rc.broadcast(StaticVariables.ROBOT_ID_CHANNEL, (i+1)*10);
					robots[i] = new RobotRepresentation(i);
					groups[0].add(rc, robots[i]);
					return;
				}
			}
		}
	}

	public static void tryToSpawn(RobotController rc) throws Exception{
		if(rc.isActive()){
			int count = rc.senseRobotCount();
			if (count < StaticVariables.MAX_ROBOTS_SPAWN) {
				Direction toEnemy = rc.getLocation().directionTo(
						rc.senseEnemyHQLocation());
				if (rc.senseObjectAtLocation(rc.getLocation().add(toEnemy)) == null) {
					rc.spawn(toEnemy);
				}
			}
		}
	}

	public static void adaptToOpponent(RobotController rc,Group[] groups ) throws Exception{
		om.scoutingData(rc);
		int count = rc.senseRobotCount();
		if(rc.senseTeamMilkQuantity(rc.getTeam()) < rc.senseTeamMilkQuantity(rc.getTeam().opponent()))
		{
			System.out.println("Opponent has more milk :(");
			groups[1].sendCommandToGroup(rc.sensePastrLocations(rc.getTeam().opponent())[0],StaticVariables.COMMAND_ATTACK_LOCATION , rc);
		}
		if(om.getOpponentModel() < 0.5){//Defensive
			System.out.println("Defensive");
			System.out.println("Adding to group 2"); //Group 2-6 is PASTR building
			if(groups[2].getSize() == 0){
				groups[1].assignToOtherGroup(rc, groups[2], 1, 1);
			}
			else if(groups[3].getSize() == 0){
				groups[1].assignToOtherGroup(rc, groups[3], 1, 1);
			}

		}else{//agressive
			System.out.println("Agressive");
			if(groups[2].getSize() == 0){
				groups[1].assignToOtherGroup(rc, groups[2], 1, 1);
			}
			if(groups[1].getSize() < count -1){
				System.out.println("Adding to group 1"); //Group 1 is attacking
				groups[2].assignToOtherGroup(rc, groups[1], 1, 1);
			}
		}
		System.out.println(om.getOpponentModel());
	}



}
