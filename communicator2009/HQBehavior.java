package communicator2009;
import java.util.Arrays;

import battlecode.common.*;

public class HQBehavior {

	/**
	 * 
	 * Defines the possible states the HQ can take in.
	 * 
	 */
	private enum HQState {
		INIT, DEFAULT;
	}
	private enum GroupState{
		INIT, ASSEMBLING, ATTACKING,WAITING,DEFENDING;
	}

	
	public static int assemblingSize = 8;
	
	public static int[] counter;
	
	/** locations that are generated by MapMaker are showing building positions **/
	public static MapLocation[] assemblyPositions;
	
	public static MapLocation attackingLoc;
	
	/** storage for the last target for the soldiers **/
	public static MapLocation lastTarget;

	public static MapLocation enemyHQ;
	public static MapLocation thisPos;

	/** The current state of the HQ. Allows to separate logical areas **/
	public static HQState state = HQState.INIT;

	/** contains the models the HQ has of the soldiers **/
	public static RobotRepresentation[] robots = new RobotRepresentation[StaticVariables.MAX_ROBOTS_SPAWN];

	/** containing all possible groups */
	public static Group[] groups;

	/** debugging constant **/
	static int lifeCount = 0;
	/** debugging constant **/
	static int byteCodeSum = 0;

	static GroupState stateGroup1,stateGroup2;
	public static MapLocation[][] path;
	static int index[];
	static boolean pathSearched = false;
	static boolean enemyPastrDestroyed = false;
	static MapLocation locGroup1;
	
	static boolean buildSended = false;
	static boolean buildSended2 = false;
	static boolean sendSoldiersToDefend = false;
	static int pastrSoldierID;
	static int retreated = 0;
	static int movingSpeed = 8;
	/**
	 * Contains the logic of the HQ. is called every round.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void hqBehavior(RobotController rc) throws Exception {
		lifeCount++;
		switch (state) {
		case INIT:
			path = new MapLocation[10][];
			stateGroup1 = GroupState.INIT;
			stateGroup2 = GroupState.INIT;
			enemyHQ = rc.senseEnemyHQLocation();
			thisPos = rc.getLocation();
			assemblyPositions = new MapLocation[1];
			assemblyPositions[0] = MapMaker.bestFound;
			groups = new Group[StaticVariables.MAX_POSSIBLE_GROUPS];
			for (int i = 0; i < groups.length; i++) {
				groups[i] = new Group(i);
			}
			state = HQState.DEFAULT;
			counter = new int[10];
			index = new int[10];
			break;
		case DEFAULT:
			tryToSpawn(rc);
			deliverID(rc);
			updateInteralRobotRepresentation(rc);
//			if(Clock.getRoundNum() >= 600){
//				sendSoldiersToDefend = true;
//			}
//			if(Clock.getRoundNum() % 200 == 0){
//				if(buildSended){
//					if(rc.sensePastrLocations(rc.getTeam()).length == 0){
//						buildSended = false;
//					}else{
//						sendSoldiersToDefend = true;
//					}
//				}
//			}
			
//			if(Clock.getRoundNum() > 400){
//				if(!buildSended){
//					groups[0].assignToOtherGroup(rc, groups[2], 0, 1);
//					groups[2].sendCommandToGroup(new MapLocation(0,0), StaticVariables.COMMAND_FOLLOW_PATH, rc);
//					if(groups[2].getSize() > 0){
//						Astar.init(rc);
//						broadcastPath(rc,0,Astar.search(rc, thisPos, assemblyPositions[0]));
//						
//						buildSended = true;
//					}
//				}
//				if(!buildSended2){
//					groups[0].assignToOtherGroup(rc, groups[3], 0, 1);
//					groups[3].sendCommandToGroup(new MapLocation(0,1), StaticVariables.COMMAND_FOLLOW_PATH, rc);
//					if(groups[3].getSize() > 0){
//
//						Astar.init(rc);
//						broadcastPath(rc,1,Astar.search(rc, thisPos, assemblyPositions[0].add(Direction.NORTH)));
//						buildSended2 = true;
//					}
//				}
//			}
			if(!sendSoldiersToDefend){
				groups[0].assignToOtherGroup(rc, groups[1], 0, 25);
			}else{
				groups[0].assignToOtherGroup(rc, groups[4], 0, 25);
			}

//			int[] pastrBuilder = groups[2].getIDs();
//			if(pastrBuilder != null && robots[pastrBuilder[0]].getLocation().equals(assemblyPositions[0])){
//				groups[2].sendCommandToGroup(assemblyPositions[0], StaticVariables.COMMAND_BUILD_PASTR, rc);
//			}
//			int[] noiseTowerBuilder = groups[3].getIDs();
//			if(noiseTowerBuilder != null && robots[noiseTowerBuilder[0]].getLocation().equals(assemblyPositions[0].add(Direction.NORTH))){
//				groups[3].sendCommandToGroup(assemblyPositions[0].add(Direction.NORTH), StaticVariables.COMMAND_BUILD_NOISE_TOWER, rc);
//			}

			switch(stateGroup1){
			case INIT:
				Astar.init(rc);
				path[3] = Astar.search(rc, thisPos, enemyHQ);
				cutPath((int)(path[3].length*0.3),3);
				broadcastPath(rc,3,path[3]);
				broadCastPathToGroup(rc, groups[1], 3, true);
				groups[1].sendCommandToGroup(null, StaticVariables.COMMAND_FORMATION_MOVE, rc);
				stateGroup1 = GroupState.ASSEMBLING;
				locGroup1 = path[3][path[3].length-1];
				break;
			case ASSEMBLING:
				double progress = followPathInFormation(rc, groups[1],3,true,true);
				if(progress == 1 && groups[1].getSize() >= assemblingSize){
					MapLocation[] enemyPastrs = rc.sensePastrLocations(rc.getTeam().opponent());
					if(enemyPastrs.length > 0){
						System.out.println("attackCommand");
						Astar.init(rc);
						path[3] = Astar.search(rc, locGroup1, enemyPastrs[0]);
						addOneToPath(3);
						broadcastPath(rc,3,path[3]);
						broadCastPathToGroup(rc, groups[1], 3, true);
						index[1] = 0;
						stateGroup1 = GroupState.ATTACKING;
					}
				}
				break;
			case ATTACKING:
				progress = followPathInFormation(rc, groups[1],3,true,false);
				double dis = getAvarageDistanceToFormation(rc, groups[1]);
				int pressure = readPressureOnGroup(groups[1], rc) ;
				if(progress == 1 && dis <= 8 && pressure == 0 && groups[1].getSize() >= 10){
					sendBuildingCommand(rc,groups[1],path[3][path[3].length-1],true);
					sendBuildingCommand(rc,groups[1],path[3][path[3].length-2],false);
					broadCastMoveTypeToGroup(rc,groups[1],true);
				}else{
					eraseBuildingCommand(rc,groups[1]);
				}
				break;
			}
			
//			if(sendSoldiersToDefend){
//				switch(stateGroup2){
//				case INIT:
//					Astar.init(rc);
//					path[4] = Astar.search(rc, thisPos, assemblyPositions[0]);
//					broadcastPath(rc,4,path[4]);
//					broadCastPathToGroup(rc, groups[4], 4, true);
//					groups[4].sendCommandToGroup(null, StaticVariables.COMMAND_FORMATION_MOVE, rc);
//					stateGroup2 = GroupState.DEFENDING;
//					break;
//				case DEFENDING:
//					followPathInFormation(rc, groups[4],4,true,false);
//					sendBuildingCommand(rc,groups[4],path[4][path[4].length-1],true);
//					sendBuildingCommand(rc,groups[4],path[4][path[4].length-2],false);
//					break;
//				}
//			}
			break;
		}
	}
	public static void addOneToPath(int pathID){
		MapLocation[] tmp = new MapLocation[path[pathID].length+1];
		for(int i = 0; i < path[pathID].length; i ++){
			tmp[i] = path[pathID][i];
		}
		tmp[tmp.length-1] = path[pathID][path[pathID].length-1].add(path[pathID][path[pathID].length-1].directionTo(enemyHQ));
		path[pathID] = tmp;
	}
	public static void cutPath(int newLength, int pathID){
		newLength = Math.min(path[pathID].length, newLength);
		if(newLength <= 0 || newLength == path[pathID].length){
			return;
		}
		MapLocation[] tmp = new MapLocation[newLength];
		for(int i = 0; i < newLength; i++){
			tmp[i] = path[pathID][i];
		}
		path[pathID] = tmp;
	}
	public static double getAvarageDistanceToFormation(RobotController rc, Group group) throws GameActionException{
		int channel = StaticVariables.ROBOT_GROUP_COMMAND_CHANNEL_START+(group.iD*StaticVariables.GROUP_CHANNEL_LENGTH_PER_GROUP);
		double counter = rc.readBroadcast(channel+10);
		double sum = rc.readBroadcast(channel+11);
	
		if(Clock.getRoundNum() % 6== 0){
			rc.broadcast(channel+10, 0);
			rc.broadcast(channel+11, 0);
		}
		if(counter == 0){
			return 100;
		}
		return sum/counter;
	}
	public static double followPathInFormation(RobotController rc, Group group,int pathID, boolean forward, boolean justAssembling) throws GameActionException{
		double dis = getAvarageDistanceToFormation(rc, group);
		int pressure = readPressureOnGroup(group, rc) ;
		int groupID = group.iD;
		if(groups[1].getSize() <= 7 && counter[groupID] >= 6 && !justAssembling){
			index[groupID] = Math.max(1, index[groupID]-1);
			counter[groupID] = 0;
		}else if((pressure == 0 && counter[groupID] >= 7 && dis <= 15) ||(dis < 1f||(dis < 8 && counter[groupID] >= 20 && pressure == 0)) || counter[groupID] >= 25){
			if(pressure == 0){
				rc.setIndicatorString(1,"GroupMovement is advancing");
				index[groupID] = Math.min(index[groupID]+1, path[pathID].length-1);
				counter[groupID] = 0;
			}	
		}else{
			counter[groupID] ++;
			rc.setIndicatorString(1,"GroupMovement is not advancing " + "counter: " + counter);
		}
		int loc = Math.min(path[pathID].length-1, index[groupID]);
		int to = Math.min(path[pathID].length-1, index[groupID]+1);
		MapLocation enemyCenter = readEnemyCenter(group, rc);
		rc.setIndicatorString(0,Clock.getRoundNum() + " GroupMovement// avgDis: "+ dis + " targetLoc" + path[pathID][loc] + " index: " + loc + " pathID " + pathID);
		if(enemyCenter != null){
			sendLineFormationCommand(rc, group, path[pathID][loc], enemyCenter);
		}else{
			sendLineFormationCommand(rc, group, path[pathID][loc], path[pathID][to]);
		}
		return (double)index[groupID]/(double)(path[pathID].length-1);
	}
	public static void broadCastPathToGroup(RobotController rc, Group group, int pathID, boolean forward) throws GameActionException{
		int channel = StaticVariables.ROBOT_GROUP_COMMAND_CHANNEL_START+(group.iD*StaticVariables.GROUP_CHANNEL_LENGTH_PER_GROUP);
		rc.broadcast(channel+8, pathID+1);
		rc.broadcast(channel+9, forward?1:0);
	}
	public static MapLocation readEnemyCenter(Group group, RobotController rc) throws GameActionException{
		int channel = StaticVariables.ROBOT_GROUP_COMMAND_CHANNEL_START+(group.iD*StaticVariables.GROUP_CHANNEL_LENGTH_PER_GROUP);
		float counter = rc.readBroadcast(channel+5);
		if(counter == 0){
			return null;
		}
		float x = rc.readBroadcast(channel+6);
		float y = rc.readBroadcast(channel+7);
		rc.broadcast(channel+5,0);
		rc.broadcast(channel+6,0);
		rc.broadcast(channel+7,0);
		return new MapLocation(Math.round(x/counter),Math.round(y/counter));
	}
	public static void broadcastPath(RobotController rc, int pathID, MapLocation[] path) throws GameActionException{
		int to = Math.min(998, path.length);
		int channel = StaticVariables.ROBOT_PATHS_DISTRIBUTION_CHANNEL_START+(pathID*1000);
		rc.broadcast(channel, path.length);
//		System.out.println(Arrays.toString(path));
		for(int i = 0; i < to; i ++){
			rc.broadcast(channel+i+1, (path[i].x)*100+path[i].y);
		}
	}
	public static void broadCastMoveTypeToGroup(RobotController rc, Group group, boolean sneaking) throws GameActionException{
		int channel = StaticVariables.ROBOT_GROUP_COMMAND_CHANNEL_START+(group.iD*StaticVariables.GROUP_CHANNEL_LENGTH_PER_GROUP);
		rc.broadcast(channel+19, sneaking?1:0);
	}
	public static void sendBuildingCommand(RobotController rc, Group group, MapLocation target, boolean pastr) throws GameActionException{
		int channel = StaticVariables.ROBOT_GROUP_COMMAND_CHANNEL_START+(group.iD*StaticVariables.GROUP_CHANNEL_LENGTH_PER_GROUP);
		if(pastr){
			rc.broadcast(channel+13, 1);
			rc.broadcast(channel+14, target.x);
			rc.broadcast(channel+15, target.y);
		}else{
			rc.broadcast(channel+16, 1);
			rc.broadcast(channel+17, target.x);
			rc.broadcast(channel+18, target.y);
		}
	}
	public static void eraseBuildingCommand(RobotController rc, Group group) throws GameActionException{
		int channel = StaticVariables.ROBOT_GROUP_COMMAND_CHANNEL_START+(group.iD*StaticVariables.GROUP_CHANNEL_LENGTH_PER_GROUP);
		rc.broadcast(channel+13, 0);
		rc.broadcast(channel+14, 0);
		rc.broadcast(channel+15, 0);
		rc.broadcast(channel+16, 0);
		rc.broadcast(channel+17, 0);
		rc.broadcast(channel+18, 0);
	}
	public static void sendLineFormationCommand(RobotController rc,Group group, MapLocation middle, MapLocation target) throws GameActionException{
		MapLocation[] result = StaticFunctions.getLineEndPoints(rc, middle	, target);
		sendLineFormation(group.iD, rc, result[0], result[1], result[2],target);
		sendPathIndex(rc,group);
//		System.out.println(result[0] + " "+ middle + " "  + result[1]);
//		group.sendCommandToGroup(result[2], StaticVariables.COMMAND_FORMATION_MOVE, rc);
	}
	public static void sendPathIndex(RobotController rc, Group group) throws GameActionException{
		int channel = StaticVariables.ROBOT_GROUP_COMMAND_CHANNEL_START+(group.iD*StaticVariables.GROUP_CHANNEL_LENGTH_PER_GROUP);
		rc.broadcast(channel+12, index[group.iD]);
	}
	public static int readPressureOnGroup(Group group, RobotController rc) throws GameActionException{
		int channel = StaticVariables.ROBOT_GROUP_COMMAND_CHANNEL_START+(group.iD*StaticVariables.GROUP_CHANNEL_LENGTH_PER_GROUP);
		int result = rc.readBroadcast(channel+4);
		if(Clock.getRoundNum() % 3==0){
			rc.broadcast(channel+4, 0);
		}
		return result;
	}
	public static void sendLineFormation(int groupID, RobotController rc,
			MapLocation p1, MapLocation p2, MapLocation middle,MapLocation target)
			throws GameActionException {
		// if(Clock.getRoundNum() < 20 ){
		// System.out.println(p1 + " " + p2 + " " + middle);
		// }

		int channel = StaticVariables.ROBOT_GROUP_COMMAND_CHANNEL_START
				+ (groupID * StaticVariables.GROUP_CHANNEL_LENGTH_PER_GROUP);
		rc.broadcast(channel, StaticFunctions.locToInt(p1));
		rc.broadcast(channel + 1, StaticFunctions.locToInt(p2));
		rc.broadcast(channel + 2, StaticFunctions.locToInt(middle));
		rc.broadcast(channel + 3, StaticFunctions.locToInt(target));
		
	}

	/**
	 * Reeds the feedback from all soldiers and updates the internal
	 * representation of the robots. This contains a counter that indicates if
	 * the soldier is alive, and also the map location of the soldiers.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void updateInteralRobotRepresentation(RobotController rc)
			throws Exception {
		for (int i = StaticVariables.MAX_ROBOTS_SPAWN; --i >= 0;) {
			if (robots[i] != null) {

				// reeds the feedback associated with this soldier.
				int feedBack = rc.readBroadcast(StaticVariables.ROBOT_FEEDBACK_CHANNEL_START
								+ i);

				// remembers the old life count of the soldier
				int current = robots[i].lifeTime;

				// sets the lifecount of the soldier to the new value.
				robots[i].lifeTime = feedBack;

				// if the old lifecount is equal to the current, than the
				// soldier died because he didn't send new feedback.
				// its a special case if the robot just spawned, in this case
				// the previous feedback is equal to the current.
				// This continues until the soldier sends the first time some
				// feedback.
				if (feedBack == current && !robots[i].initilazie) {

					rc.broadcast(StaticVariables.ROBOT_FEEDBACK_CHANNEL_START
							+ i, 0);
					rc.broadcast(StaticVariables.ROBOT_COMMAND_CHANNEL_START
							+ i, 0);
					robots[i].notifyDeath();
					robots[i] = null;
				} else if (feedBack != current) {
					robots[i].initilazie = false;
				}
			}
		}
	}

	/**
	 * Reads the broadcast channel allocated for the robot id's. A 1 stands for
	 * a request for a new ID. The HQ looks for the next free space in the list
	 * of soldier-representations. The index of this channel +1 is the new ID
	 * which is written back into the ID-channel. The Soldier reads this ID and
	 * clears the ID-channel(writing 0 into the ID-channel) for new requests.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void deliverID(RobotController rc) throws Exception {
		int current = rc.readBroadcast(StaticVariables.ROBOT_ID_CHANNEL);
		if (current == 1) {
			for (int i = 0; i < robots.length; i++) {
				if (robots[i] == null) {
					rc.broadcast(StaticVariables.ROBOT_ID_CHANNEL, (i + 1) * 10);
					robots[i] = new RobotRepresentation(i);
					groups[0].add(rc, robots[i]);
					return;
				}
			}
		}
	}

	public static void tryToSpawn(RobotController rc) throws Exception {
		if (rc.isActive()) {
			int count = rc.senseRobotCount();
			if (count < StaticVariables.MAX_ROBOTS_SPAWN) {
				for (int i = 0; i < 8; i++) {
					if (rc.senseObjectAtLocation(HQBehavior.thisPos
							.add(StaticVariables.directions[i])) == null
							&& rc.canMove(StaticVariables.directions[i])) {
						rc.spawn(StaticVariables.directions[i]);
						return;
					}
				}

			}
		}
	}

}
/**



MapLocation[] enemyPastr = rc.sensePastrLocations(rc.getTeam().opponent());
if((enemyPastr.length > 0 && groups[1].getSize() >=6)|| enemyPastrDestroyed){
	if(!pathSearched){
		Astar.init(rc);
		path = Astar.search(rc, assemblyPositions[0], enemyPastr[0]);
		index = 0;
		pathSearched = true;
	}
	if(groups[1].getSize() < 3){
		index = 1;
	}
//	System.out.println(readPressureOnGroup(groups[1], rc));
	if(Clock.getRoundNum() % movingSpeed == 0){
		int pressure = readPressureOnGroup(groups[1], rc) ;
		if(pressure > 0){
			index = Math.max(0, index);
			retreated = 1;
		}else{
			index += 1 + retreated;
			retreated = 0;
		}
		int loc = Math.min(path.length-1, index);
		int to = Math.min(path.length-1, index+1);
		MapLocation enemyCenter = readEnemyCenter(groups[1], rc);
		if(enemyCenter != null){
			sendLineFormationCommand(rc, groups[1], path[loc], enemyCenter);
		}else{
			sendLineFormationCommand(rc, groups[1], path[loc], path[to]);
		}
	}
}else{
	if(pathSearched){
		enemyPastrDestroyed = true;
		break;
	}
	index = 0;
	sendLineFormationCommand(rc, groups[1],assemblyPositions[0].add(assemblyPositions[0].directionTo(enemyHQ), 2), enemyHQ);
}
*/