package communicator2010;
import java.util.Arrays;

import battlecode.common.*;

public class HQBehavior {

	/**
	 * 
	 * Defines the possible states the HQ can take in.
	 * 
	 */
	private enum HQState {
		INIT, DEFAULT;
	}
	private enum GroupState{
		INIT, ASSEMBLING, ATTACKING,WAITING,DEFENDING;
	}

	
	public static int assemblingSize = 8;
	
	public static int counter;
	
	/** locations that are generated by MapMaker are showing building positions **/
	public static MapLocation assemblyPosition;
	
	public static MapLocation attackingLoc;
	
	/** storage for the last target for the soldiers **/
	public static MapLocation lastTarget;

	public static MapLocation enemyHQ;
	public static MapLocation thisPos;

	/** The current state of the HQ. Allows to separate logical areas **/
	public static HQState state = HQState.INIT;

	/** contains the models the HQ has of the soldiers **/
	public static RobotRepresentation[] robots = new RobotRepresentation[StaticVariables.MAX_ROBOTS_SPAWN];

	/** containing all possible groups */
	public static Group[] groups;

	/** debugging constant **/
	static int lifeCount = 0;
	/** debugging constant **/
	static int byteCodeSum = 0;

	static GroupState stateGroup1,stateGroup2;
	public static MapLocation[][] path;
	static int index[];
	static boolean pathSearched = false;
	static boolean enemyPastrDestroyed = false;
	static MapLocation locGroup1, attackLocGroup1;
	
	static boolean buildSended = false;
	static boolean buildSended2 = false;
	static boolean sendSoldiersToDefend = false;
	static int pastrSoldierID;
	static int retreated = 0;
	static int movingSpeed = 8;
	static GroupBehaviour gB1,gB2,gB3;
	static boolean bigMap = false;
	
	/**
	 * Contains the logic of the HQ. is called every round.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void hqBehavior(RobotController rc) throws Exception {
		lifeCount++;
		switch (state) {
		case INIT:
			if((rc.getMapHeight()+rc.getMapWidth())/2 >= 50){
				bigMap = true;
			}
			path = new MapLocation[10][];
			stateGroup1 = GroupState.INIT;
			stateGroup2 = GroupState.INIT;
			enemyHQ = rc.senseEnemyHQLocation();
			thisPos = rc.getLocation();
			MapMaker.init(rc);
			MapMaker.assessMapLocations();
			assemblyPosition = MapMaker.findBestPastureLocation();
			System.out.println("build at " + assemblyPosition);
			groups = new Group[StaticVariables.MAX_POSSIBLE_GROUPS];
			for (int i = 0; i < groups.length; i++) {
				groups[i] = new Group(i);
			}
			state = HQState.DEFAULT;
			counter =0;
			gB1 = new GroupBehaviour(groups[1]);
			gB2 = new GroupBehaviour(groups[2]);
			gB3 = new GroupBehaviour(groups[3]);
			break;
		case DEFAULT:
			tryToSpawn(rc);
			deliverID(rc);
			updateInteralRobotRepresentation(rc);
			counter ++;
			if(counter >= 100&& groups[2].getSize() == 0 && buildSended){
				if(!gB2.isBuilded(rc, true)&&rc.sensePastrLocations(rc.getTeam()).length == 0){
					System.out.println("try to send another build");
					counter = 0;
					buildSended = false;
				}
			}
			if((Clock.getRoundNum() > 600 && !buildSended)|| (bigMap && !buildSended)){
				groups[0].assignToOtherGroup(rc, groups[2], 0, 2);
				groups[0].assignToOtherGroup(rc, groups[1], 0, 25);
			}else{
				groups[0].assignToOtherGroup(rc, groups[1], 0, 25);
			}

			if(groups[2].getSize() >= 2 && !buildSended){
				double progress = gB2.run(rc, assemblyPosition, thisPos, 1,true,0);
				if(progress == 1 && gB2.dis <= 5){
					RobotRepresentation[] builders = groups[2].getRobots();
					int size = groups[2].getSize();
					if(size >= 1){
						MapLocation pastrLoc = null,noiseTowerLoc = null;
						if(gB2.path.length <= 2){
							pastrLoc = gB2.path[gB2.path.length-1];
							if((noiseTowerLoc = StaticFunctions.getFirstFreeTile(pastrLoc, rc))== null){
								size = 1;
							}
						}else{
							pastrLoc = gB2.path[gB2.path.length-1];
							noiseTowerLoc = gB2.path[gB2.path.length-2];
						}
						int location = pastrLoc!=null?StaticFunctions.locToInt(pastrLoc):0;
						int broadcast = location + (StaticVariables.COMMAND_BUILD_PASTR*100000);
						rc.broadcast(StaticVariables.ROBOT_COMMAND_CHANNEL_START+builders[0].iD, broadcast);
						if(size >= 2){
							location = pastrLoc!=null?StaticFunctions.locToInt(noiseTowerLoc):0;
							broadcast = location + (StaticVariables.COMMAND_BUILD_NOISE_TOWER*100000);
							rc.broadcast(StaticVariables.ROBOT_COMMAND_CHANNEL_START+builders[1].iD, broadcast);
							buildSended = true;
							counter = 0;
							System.out.println("time build sended: " + Clock.getRoundNum() + " dis: " + gB2.dis);
						}
					}

				}
			}
			switch(stateGroup1){
			case INIT:
				gB1.run(rc, enemyHQ, thisPos, 0.3d,false,0);
				locGroup1 = gB1.path[gB1.path.length-1];
				stateGroup1 = GroupState.ASSEMBLING;
				break;
			case ASSEMBLING:
				double progress = gB1.run(rc, enemyHQ, thisPos, 0.3d,false,0);
				if(progress == 1 && groups[1].getSize() >= assemblingSize){
					MapLocation[] enemyPastrs = rc.sensePastrLocations(rc.getTeam().opponent());
					if(enemyPastrs.length > 0){
						attackLocGroup1 = enemyPastrs[0];
						gB1.run(rc, attackLocGroup1, locGroup1, 1,false,2);
						stateGroup1 = GroupState.ATTACKING;
					}
				}
				break;
			case ATTACKING:
				progress = gB1.run(rc, attackLocGroup1, locGroup1, 1,false,2);
//				System.out.println("attacking avgDis: " + gB1.dis + " pressure: " + gB1.pressure);
				gB1.sendBuildCommandIfAppropiate(rc);
				break;
			}

			break;
		}
	}
	
	


	/**
	 * Reeds the feedback from all soldiers and updates the internal
	 * representation of the robots. This contains a counter that indicates if
	 * the soldier is alive, and also the map location of the soldiers.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void updateInteralRobotRepresentation(RobotController rc)
			throws Exception {
		for (int i = StaticVariables.MAX_ROBOTS_SPAWN; --i >= 0;) {
			if (robots[i] != null) {

				// reeds the feedback associated with this soldier.
				int feedBack = rc.readBroadcast(StaticVariables.ROBOT_FEEDBACK_CHANNEL_START
								+ i);

				// remembers the old life count of the soldier
				int current = robots[i].lifeTime;

				// sets the lifecount of the soldier to the new value.
				robots[i].lifeTime = feedBack;

				// if the old lifecount is equal to the current, than the
				// soldier died because he didn't send new feedback.
				// its a special case if the robot just spawned, in this case
				// the previous feedback is equal to the current.
				// This continues until the soldier sends the first time some
				// feedback.
				if (feedBack == current && !robots[i].initilazie) {

					rc.broadcast(StaticVariables.ROBOT_FEEDBACK_CHANNEL_START
							+ i, 0);
					rc.broadcast(StaticVariables.ROBOT_COMMAND_CHANNEL_START
							+ i, 0);
					robots[i].notifyDeath();
					robots[i] = null;
				} else if (feedBack != current) {
					robots[i].initilazie = false;
				}
			}
		}
	}

	/**
	 * Reads the broadcast channel allocated for the robot id's. A 1 stands for
	 * a request for a new ID. The HQ looks for the next free space in the list
	 * of soldier-representations. The index of this channel +1 is the new ID
	 * which is written back into the ID-channel. The Soldier reads this ID and
	 * clears the ID-channel(writing 0 into the ID-channel) for new requests.
	 * 
	 * @param rc
	 * @throws Exception
	 */
	public static void deliverID(RobotController rc) throws Exception {
		int current = rc.readBroadcast(StaticVariables.ROBOT_ID_CHANNEL);
		if (current == 1) {
			for (int i = 0; i < robots.length; i++) {
				if (robots[i] == null) {
					rc.broadcast(StaticVariables.ROBOT_ID_CHANNEL, (i + 1) * 10);
					robots[i] = new RobotRepresentation(i);
					groups[0].add(rc, robots[i]);
					return;
				}
			}
		}
	}

	public static void tryToSpawn(RobotController rc) throws Exception {
		if (rc.isActive()) {
			int count = rc.senseRobotCount();
			if (count < StaticVariables.MAX_ROBOTS_SPAWN) {
				for (int i = 0; i < 8; i++) {
					if (rc.senseObjectAtLocation(HQBehavior.thisPos
							.add(StaticVariables.directions[i])) == null
							&& rc.canMove(StaticVariables.directions[i])) {
						rc.spawn(StaticVariables.directions[i]);
						return;
					}
				}

			}
		}
	}

}
/**



MapLocation[] enemyPastr = rc.sensePastrLocations(rc.getTeam().opponent());
if((enemyPastr.length > 0 && groups[1].getSize() >=6)|| enemyPastrDestroyed){
	if(!pathSearched){
		Astar.init(rc);
		path = Astar.search(rc, assemblyPositions[0], enemyPastr[0]);
		index = 0;
		pathSearched = true;
	}
	if(groups[1].getSize() < 3){
		index = 1;
	}
//	System.out.println(readPressureOnGroup(groups[1], rc));
	if(Clock.getRoundNum() % movingSpeed == 0){
		int pressure = readPressureOnGroup(groups[1], rc) ;
		if(pressure > 0){
			index = Math.max(0, index);
			retreated = 1;
		}else{
			index += 1 + retreated;
			retreated = 0;
		}
		int loc = Math.min(path.length-1, index);
		int to = Math.min(path.length-1, index+1);
		MapLocation enemyCenter = readEnemyCenter(groups[1], rc);
		if(enemyCenter != null){
			sendLineFormationCommand(rc, groups[1], path[loc], enemyCenter);
		}else{
			sendLineFormationCommand(rc, groups[1], path[loc], path[to]);
		}
	}
}else{
	if(pathSearched){
		enemyPastrDestroyed = true;
		break;
	}
	index = 0;
	sendLineFormationCommand(rc, groups[1],assemblyPositions[0].add(assemblyPositions[0].directionTo(enemyHQ), 2), enemyHQ);
}
*/